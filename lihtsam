"""
Car Rental – Super Simple Version
---------------------------------
Changes from the original:
- Uses DD/MM/YYYY date format.
- Costs are integers only (no decimals/cents). 
- Keeps just the essentials: Cars, Customers, Rentals, basic CLI.
- No file persistence (to keep it super simple).

Run:
    python simple_rental.py
"""
from __future__ import annotations
from dataclasses import dataclass
from datetime import date, datetime
from typing import Dict, List, Optional

# ==========================
# Simple Domain Models
# ==========================
@dataclass
class Car:
    car_id: int
    registration: str
    make: str
    model: str
    year: int
    daily_rate_aud: int = 120  # integers only
    active: bool = True

@dataclass
class Customer:
    customer_id: int
    full_name: str
    license_no: str

@dataclass
class Rental:
    rental_id: int
    car_id: int
    customer_id: int
    start_date: date
    end_date: date
    daily_rate_aud: int  # integers only
    returned: bool = False
    total_cost_aud: Optional[int] = None  # integers only

    @property
    def days(self) -> int:
        # charge by nights; minimum 1 day
        d = (self.end_date - self.start_date).days
        return d if d > 0 else 1

    def compute_cost(self) -> int:
        # integer arithmetic only
        return self.days * self.daily_rate_aud

# ==========================
# Manager
# ==========================
class RentalManager:
    def __init__(self):
        self.cars: Dict[int, Car] = {}
        self.customers: Dict[int, Customer] = {}
        self.rentals: Dict[int, Rental] = {}
        self._car_seq = 0
        self._cust_seq = 0
        self._rent_seq = 0

    # ---- ID helpers (simple counters) ----
    def _next_car_id(self) -> int:
        self._car_seq += 1
        return self._car_seq

    def _next_cust_id(self) -> int:
        self._cust_seq += 1
        return self._cust_seq

    def _next_rent_id(self) -> int:
        self._rent_seq += 1
        return self._rent_seq

    # ---- Car ops ----
    def add_car(self, registration: str, make: str, model: str, year: int, daily_rate_aud: int = 120) -> Car:
        if daily_rate_aud <= 0:
            raise ValueError("daily_rate_aud must be positive (integer)")
        regu = registration.strip().upper()
        if not regu:
            raise ValueError("registration required")
        if any(c.registration == regu for c in self.cars.values()):
            raise ValueError("registration already exists")
        cid = self._next_car_id()
        car = Car(cid, regu, make, model, year, daily_rate_aud)
        self.cars[cid] = car
        return car

    def list_available_cars(self, start: date, end: date) -> List[Car]:
        return [c for c in self.cars.values() if c.active and self._is_car_available(c.car_id, start, end)]

    def _is_car_available(self, car_id: int, start: date, end: date) -> bool:
        for r in self.rentals.values():
            if r.car_id != car_id or r.returned is True:
                continue
            # overlap check (end exclusive)
            if not (end <= r.start_date or start >= r.end_date):
                return False
        return True

    # ---- Customer ops ----
    def add_customer(self, full_name: str, license_no: str) -> Customer:
        name = full_name.strip()
        lic = license_no.strip()
        if not name or not lic:
            raise ValueError("full_name and license_no required")
        uid = self._next_cust_id()
        cust = Customer(uid, name, lic)
        self.customers[uid] = cust
        return cust

    # ---- Rental ops ----
    def rent_car(self, car_id: int, customer_id: int, start: date, end: date) -> Rental:
        if car_id not in self.cars:
            raise ValueError("car not found")
        if customer_id not in self.customers:
            raise ValueError("customer not found")
        if end <= start:
            raise ValueError("end must be after start")
        if not self._is_car_available(car_id, start, end):
            raise ValueError("car not available for those dates")
        rate = self.cars[car_id].daily_rate_aud
        rid = self._next_rent_id()
        rental = Rental(rid, car_id, customer_id, start, end, rate)
        self.rentals[rid] = rental
        return rental

    def return_car(self, rental_id: int) -> Rental:
        if rental_id not in self.rentals:
            raise ValueError("rental not found")
        r = self.rentals[rental_id]
        if r.returned:
            raise ValueError("already returned")
        r.returned = True
        r.total_cost_aud = r.compute_cost()  # integer
        return r

    # ---- Reports ----
    def active_rentals(self) -> List[Rental]:
        return [r for r in self.rentals.values() if not r.returned]

    def revenue_between(self, start: date, end: date) -> int:
        total = 0
        for r in self.rentals.values():
            if r.returned and start <= r.end_date <= end:
                total += (r.total_cost_aud if r.total_cost_aud is not None else r.compute_cost())
        return total

# ==========================
# Helpers & CLI
# ==========================
DATE_FMT = "%d/%m/%Y"  # DD/MM/YYYY


def parse_date(s: str) -> date:
    return datetime.strptime(s.strip(), DATE_FMT).date()


def format_date(d: date) -> str:
    return d.strftime(DATE_FMT)


def seed_nine_xc90s(mgr: RentalManager):
    plates = [
        "XC90A01", "XC90A02", "XC90A03", "XC90A04", "XC90A05",
        "XC90A06", "XC90A07", "XC90A08", "XC90A09",
    ]
    for p in plates:
        mgr.add_car(p, "Volvo", "XC90", 2008, daily_rate_aud=120)


MENU = """
\nCar Rental – Super Simple Menu
[1] List available cars for dates (DD/MM/YYYY)
[2] Add customer
[3] Rent a car
[4] Return a car
[5] Show active rentals
[6] Show revenue for a period (DD/MM/YYYY)
[7] Quit\n"""


def main():
    mgr = RentalManager()
    seed_nine_xc90s(mgr)
    print("Ready. Cars:", len(mgr.cars))

    while True:
        try:
            print(MENU)
            choice = input("Choose an option: ").strip()

            if choice == "1":
                s = input("Start date (DD/MM/YYYY): ")
                e = input("End date (DD/MM/YYYY): ")
                start, end = parse_date(s), parse_date(e)
                avail = mgr.list_available_cars(start, end)
                if not avail:
                    print("No cars available.")
                else:
                    for c in avail:
                        print(f"- {c.car_id}: {c.registration} {c.make} {c.model} {c.year} | ${c.daily_rate_aud}/day")

            elif choice == "2":
                name = input("Full name: ")
                lic = input("Driver license no: ")
                cust = mgr.add_customer(name, lic)
                print(f"Customer added: id={cust.customer_id}, name={cust.full_name}")

            elif choice == "3":
                cid = int(input("Car ID: ").strip())
                uid = int(input("Customer ID: ").strip())
                s = input("Start date (DD/MM/YYYY): ")
                e = input("End date (DD/MM/YYYY): ")
                start, end = parse_date(s), parse_date(e)
                try:
                    r = mgr.rent_car(cid, uid, start, end)
                    print(f"Rental created: id={r.rental_id} | Est. cost: ${r.compute_cost()}")
                except Exception as ex:
                    print("Error:", ex)

            elif choice == "4":
                rid = int(input("Rental ID to return: ").strip())
                try:
                    r = mgr.return_car(rid)
                    print(f"Returned. Total cost: ${r.total_cost_aud}")
                except Exception as ex:
                    print("Error:", ex)

            elif choice == "5":
                act = mgr.active_rentals()
                if not act:
                    print("No active rentals.")
                else:
                    for r in act:
                        car = mgr.cars[r.car_id]
                        cust = mgr.customers[r.customer_id]
                        print(
                            f"- rental {r.rental_id} | car {car.registration} -> {cust.full_name} | "
                            f"{format_date(r.start_date)} to {format_date(r.end_date)} | ${r.daily_rate_aud}/day"
                        )

            elif choice == "6":
                s = input("From date (DD/MM/YYYY): ")
                e = input("To date (DD/MM/YYYY): ")
                start, end = parse_date(s), parse_date(e)
                total = mgr.revenue_between(start, end)
                print(f"Revenue between {format_date(start)} and {format_date(end)}: ${total}")

            elif choice == "7":
                print("Goodbye!")
                break

            else:
                print("Invalid option. Try again.")

        except KeyboardInterrupt:
            print("\nExiting...")
            break
        except Exception as ex:
            print("Unexpected error:", ex)


if __name__ == "__main__":
    main()
